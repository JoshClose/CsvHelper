{"path":"mapping","templateID":0,"sharedPropsHashes":{},"localProps":{"className":"mapping","data":"# Class Mapping\r\n\r\nSometimes your class members and CSV headers don't match up. Sometimes your CSV files don't have a header row and you need to specify an index for a member [because you can't rely on the ordering of class members in .NET](https://blogs.msdn.microsoft.com/haibo_luo/2006/07/10/member-order-returned-by-getfields-getmethods/). For these situations you can create a class map that maps a class member to a CSV field using the configuration you specify.\r\n\r\nTo create a mapping from a class to a CSV file, you use a `ClassMap`. You can map any public members (properties or fields).\r\n\r\n```cs\r\npublic class MyClass\r\n{\r\n\tpublic int Id { get; set; }\r\n\tpublic string Name { get; set; }\r\n}\r\n\r\npublic sealed class MyClassMap : ClassMap<MyClass>\r\n{\r\n\tpublic MyClassMap()\r\n\t{\r\n\t\tMap( m => m.Id );\r\n\t\tMap( m => m.Name );\r\n\t}\r\n}\r\n```\r\n\r\nTo use this mapping, you need to register the mapping in the configuration.\r\n\r\n```cs\r\nvar csv = new CsvReader( textReader );\r\ncsv.Configuration.RegisterClassMap<MyClassMap>();\r\n```\r\n\r\n## Reference Mapping\r\n\r\n<hr/>\r\n\r\nTo map a reference member, just reference the member down the tree. You can reference as far down the tree as you need.\r\n\r\n```cs\r\npublic class A\r\n{\r\n\tpublic int Id { get; set; }\r\n\tpublic B B { get; set; }\r\n}\r\n\r\npublic class B\r\n{\r\n\tpublic int Id { get; set; }\r\n\tpublic C C { get; set; }\r\n}\r\n\r\npublic class C\r\n{\r\n\tpublic int Id { get; set; }\r\n}\r\n\r\npublic sealed class AMap : ClassMap<A>\r\n{\r\n\tpublic AMap()\r\n\t{\r\n\t\tMap( m => m.Id ).Name( \"A\" );\r\n\t\tMap( m => m.B.Id ).Name( \"B\" );\r\n\t\tMap( m => m.B.C.Id).Name( \"C\" );\r\n\t}\r\n}\r\n```\r\n\r\n## Auto Mapping\r\n\r\n<hr/>\r\n\r\nIf you don't supply a mapping file and try to read or write, a mapping file is automatically created for you through auto mapping. Auto mapping will traverse the object graph and create member mappings for you using defaults. You can change some of these defaults through configuration. If a circular reference is detected, the auto mapper will stop traversing that tree node and continue with the next.\r\n\r\nYou can also call `AutoMap` in your `ClassMap`. If you only have a few changes you want to make, you can use `AutoMap` to create the initial map, then make only the changes you want.\r\n\r\n```cs\r\npublic class MyClass\r\n{\r\n\tpublic int Id { get; set; }\r\n\r\n\tpublic string Name { get; set; }\r\n\r\n\tpublic DateTime CreatedDate { get; set; }\r\n}\r\n\r\npublic sealed class MyClassMap : ClassMap<MyClass>\r\n{\r\n\tpublic MyClassMap()\r\n\t{\r\n\t\tAutoMap();\r\n\t\tMap( m => m.CreatedDate ).Ignore();\r\n\t}\r\n}\r\n```\r\n\r\n## Options\r\n\r\n<hr/>\r\n\r\nYou are able change the behavior of the member mapping through options.\r\n\r\n### Name\r\n\r\nSpecifies the name of the field header. You can pass in multiple names if the field might have more than one name that is used for it when reading. All the names will be checked when looking for the field. When writing, only the first name is used.\r\n\r\n```cs\r\n// Single name\r\nMap( m => m.Id ).Name( \"id\" );\r\n\r\n// Multiple possible names\r\nMap( m => m.Id ).Name( \"id\", \"the_id\", \"Id\" );\r\n```\r\n\r\n### NameIndex\r\n\r\nSpecifies the zero-based index of the header name if the header name appears in more than one column.\r\n\r\n```cs\r\n// Example header\r\nid,name,id\r\n\r\n// Mapping\r\nMap( m => m.Id ).Name( \"id\" ).NameIndex( 1 );\r\n```\r\n\r\n### Index\r\n\r\nSpecifies the zero-based index of the field. When reading this is used if there is no header. A name will override an index. When writing you can specify both so that the position of the column is guaranteed.\r\n\r\n```cs\r\nMap( m => m.Id ).Index( 0 );\r\n```\r\n\r\n### Default\r\n\r\nSpecifies a default value when reading that will be used when a field is empty.\r\n\r\n```cs\r\nMap( m => m.Name ).Default( \"empty\" );\r\n```\r\n\r\n### Constant\r\n\r\nSpecifies a value that will be used as a constant for a field when reading and writing. This value will always be used regardless of other mapping configurations.\r\n\r\n```cs\r\nMap( m => m.Name ).Constant( \"never changes\" );\r\n```\r\n\r\n### Ignore\r\n\r\nIgnores the member when reading and writing. Note: If this member has already been mapped as a reference member, either by a class map, or by auto mapping, calling this method will not ignore all the child members down the tree that have already been mapped.\r\n\r\n```cs\r\nMap( m => m.Name ).Ignore();\r\n```\r\n\r\n### TypeConverter\r\n\r\nSpecifies the `ITypeConverter` that is used when converting the member to and from a CSV field.\r\n\r\n```cs\r\nMap( m => m.Name ).TypeConverter( new MyConverter() );\r\nMap( m => m.Name ).TypeConverter<MyConverter>();\r\n```\r\n\r\n### ConvertUsing\r\n\r\nSpecifies an expression to be used to convert a field to a member, or a member to a field.\r\n\r\nReading:\r\n\r\n```cs\r\n// Convert to member\r\nMap( m => m.Aggregate ).ConvertUsing( row => row.Get<int>( \"A\" ) + row.Get<int>( \"B\" ) );\r\n\r\n// Block\r\nMap( m => m.Aggregate ).ConvertUsing( row =>\r\n{\r\n\tvar a = row.Get<int>( \"A\" );\r\n\tvar b = row.Get<int>( \"B\" );\r\n\treturn a + b;\r\n} );\r\n```\r\n\r\nWriting:\r\n\r\n```cs\r\n// Convert to field\r\nMap( m => m.Aggregate ).ConvertUsing( m => $\"A + B = {m.A + m.B}\" );\r\n\r\n// Block\r\nMap( m => m.Aggregate ).ConvertUsing( m =>\r\n{\r\n\tvar field = \"A + B = \";\r\n\tfield += ( m.A + m.B ).ToString();\r\n\treturn field;\r\n} );\r\n```\r\n\r\n### Validate\r\n\r\nSpecifies an expression to be used to validate a field when reading. If the expression returns `false`, a `ValidationException` is thrown.\r\n\r\n```cs\r\n// Ensure field isn't blank.\r\nMap( m => m.Number ).Validate( field => !string.IsNullOrEmpty( field ) );\r\n\r\n// Log error instead of throwing an exception.\r\nMap( m => m.Number ).Validate( field =>\r\n{\r\n\tvar isValid = !string.IsNullOrEmpty( field );\r\n\tif( !isValid )\r\n\t{\r\n\t\tlogger.AppendLine( $\"Field '{field}' is not valid!\" );\r\n\t}\r\n\r\n\treturn true;\r\n} );\r\n```\r\n\r\n<br/>\r\n"}}
