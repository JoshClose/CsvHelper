<!DOCTYPE html><html lang="en-US" data-reactroot=""><head><title data-react-helmet="true"></title><link rel="preload" as="script" href="http://joshclose.github.io/CsvHelper/test/routeInfo.2wAekb.js"/><link rel="preload" as="script" href="http://joshclose.github.io/CsvHelper/test/bootstrap.f10da1f5.js"/><link rel="preload" as="script" href="http://joshclose.github.io/CsvHelper/test/templates/src/components/content.96d459ed.js"/><link rel="preload" as="script" href="http://joshclose.github.io/CsvHelper/test/main.df014947.js"/><link rel="preload" as="style" href="http://joshclose.github.io/CsvHelper/test/styles.6a918a28.css"/><link rel="stylesheet" href="http://joshclose.github.io/CsvHelper/test/styles.6a918a28.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/></head><body><div id="root"><div class="layout" data-reactroot=""><a class="fork-me-on-github" href="https://github.com/joshclose/csvhelper" target="_blank"><img src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/></a><header class="header"><div class="container"><nav class="navbar"><div class="navbar-brand"><a class="navbar-item active" aria-current="true" href="http://joshclose.github.io/CsvHelper/test/"><img src="./images/logo-header.png" width="66" height="28"/></a><div class="navbar-burger burger"><span></span><span></span><span></span></div></div><div class="navbar-menu"><div class="navbar-start"><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading">Reading</a><div class="navbar-dropdown"><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading#getting-all-records">Getting All Records</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading#reading-records">Reading Records</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading#getting-a-single-record">Getting a Single Record</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading#getting-fields">Getting Fields</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading#malformed-field-fallback">Malformed Field Fallback</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading#reading-context">Reading Context</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./reading#configuration">Configuration</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./writing">Writing</a><div class="navbar-dropdown"><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./writing#writing-all-records">Writing All Records</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./writing#writing-a-single-record">Writing a Single Record</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./writing#writing-fields">Writing Fields</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./writing#ending-the-row">Ending the Row</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./writing#writing-context">Writing Context</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./writing#configuration">Configuration</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./mapping">Mapping</a><div class="navbar-dropdown"><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./mapping#reference-mapping">Reference Mapping</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./mapping#auto-mapping">Auto Mapping</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./mapping#options">Options</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration">Configuration</a><div class="navbar-dropdown"><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#malicious-injection-protection">Malicious Injection Protection</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#headers">Headers</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#mapping">Mapping</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#constructor-mapping">Constructor Mapping</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#error-handling">Error Handling</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#type-conversion">Type Conversion</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#reading">Reading</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#parsing">Parsing</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#writing">Writing</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./configuration#formatting">Formatting</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./type-conversion">Type Conversion</a><div class="navbar-dropdown"></div></div><div class="navbar-item has-dropdown is-hoverable"><div class="navbar-link">Misc</div><div class="navbar-dropdown"><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./examples">Examples</a><a class="navbar-item" aria-current="false" href="http://joshclose.github.io/CsvHelper/test/./change-log">Change Log</a></div></div></div></div></nav></div><div class="navbar"></div></header><div class="container"><div class="reading"><h1 id="reading" class="title is-1"><span>Reading</span></h1><div class="columns"><div class="column"><p>This library was created to work as easy as possible without any configuration by default. If your class property names match your CSV file header names, it&#39;s as simple as this.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-keyword">var</span> csv = <span class="hljs-keyword">new</span> CsvReader( textReader );
<span class="hljs-keyword">var</span> records = csv.GetRecords&lt;MyClass&gt;();</code></pre></div></div><h2 id="getting-all-records" class="title is-2"><span>Getting All Records</span></h2><hr/>

<div class="columns"><div class="column"><p>The most common scenario is using one of the <code>GetRecords</code> methods.  You can specify the type of object you want returned, and it will return an <code>IEnumerable</code> that will <code>yield</code> results. This means when iterating the results, only a single record will be in memory at a time, instead of the entire file. Records aren&#39;t pulled until you actually start iterating the results.</p></div></div><div class="columns"><div class="column"><p>If you want to use an anonymous type as your record, you can get the records by supplying a type definition. You can use <code>default( type )</code> for value types, and <code>new</code> for reference types.</p></div></div><h3 id="getrecords" class="title is-3"><span>GetRecords</span></h3><div class="columns"><div class="column"><p>Returns an <code>IEnumerable&lt;T&gt;</code> of records.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-comment">// By type</span>
<span class="hljs-keyword">var</span> records = csv.GetRecords&lt;MyClass&gt;();
<span class="hljs-keyword">var</span> records = csv.GetRecords( <span class="hljs-keyword">typeof</span>( MyClass ) );

<span class="hljs-comment">// Dynamic</span>
<span class="hljs-keyword">var</span> records = csv.GetRecords&lt;<span class="hljs-keyword">dynamic</span>&gt;();

<span class="hljs-comment">// Using anonymous type for the class definition</span>
<span class="hljs-keyword">var</span> anonymousTypeDefinition =
{
    Id = <span class="hljs-keyword">default</span>( <span class="hljs-keyword">int</span> ),
    Name = <span class="hljs-keyword">string</span>.Empty,
    MyClass = <span class="hljs-keyword">new</span> MyClass()
};
<span class="hljs-keyword">var</span> records = csv.GetRecords( anonymousTypeDefinition );</code></pre></div></div><h3 id="enumeraterecords" class="title is-3"><span>EnumerateRecords</span></h3><div class="columns"><div class="column"><p>You can also enumerate the records while re-using a class instance that you give.
Each enumeration will hydrate the given record, but only the mapped members. If you
supplied a map and didn&#39;t map one of the members, that member will not get hydrated
with the current row&#39;s data. Be careful. Any methods that you call on the projection
that force the evaluation of the <code>IEnumerable</code>, such as <code>ToList()</code>, you will get a
list where all the records are the same instance you provided that is hydrated with
the last record in the CSV file.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-keyword">var</span> record = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-keyword">var</span> records = csv.EnumerateRecords( record );
<span class="hljs-keyword">foreach</span>( <span class="hljs-keyword">var</span> r <span class="hljs-keyword">in</span> records )
{
    <span class="hljs-comment">// r is the same instance as record.</span>
}</code></pre></div></div><h2 id="reading-records" class="title is-2"><span>Reading Records</span></h2><hr/>

<div class="columns"><div class="column"><p>To be able to get individual records or even fields, you need to iterate through the records. This is done using the <code>Read</code> methods. <code>Read</code> will advance the reader to the next record. You must call <code>Read</code> before you can get any records or fields. When <code>GetRecords</code>, <code>Read</code> is automatically called for you.</p></div></div><h3 id="read" class="title is-3"><span>Read</span></h3><div class="columns"><div class="column"><p>This will advance the reader to the next record.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs">csv.Read();</code></pre></div></div><h3 id="readasync" class="title is-3"><span>ReadAsync</span></h3><div class="columns"><div class="column"><p>This will advance the reader to the next record asynchronously. If the <code>TextReader</code> that was supplied is tied to a network or some other slow to read functionality, reading asynchronously is probably a good idea.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-keyword">await</span> csv.ReadAsync();</code></pre></div></div><h3 id="readheader" class="title is-3"><span>ReadHeader</span></h3><div class="columns"><div class="column"><p>The header in a CSV file is just another record, but it has special meaning. If your file has a header record, you&#39;ll need to read the header after the first read. After that you can loop the records and read them. This will allow you to be able to read headers on different rows, or even multiple headers.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs">csv.Read();
csv.ReadHeader();
<span class="hljs-keyword">while</span>( csv.Read() )
{
    <span class="hljs-keyword">var</span> record = csv.GetRecord&lt;MyClass&gt;();
}</code></pre></div></div><h2 id="getting-a-single-record" class="title is-2"><span>Getting a Single Record</span></h2><hr/>

<div class="columns"><div class="column"><p>Sometimes there is a reason that you may need to loop the records yourself. You can still easily get a single record, just like with multiple records.</p></div></div><h3 id="getrecord" class="title is-3"><span>GetRecord</span></h3><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-comment">// Don't forget to read the data before getting it.</span>
csv.Read();

<span class="hljs-comment">// By type</span>
<span class="hljs-keyword">var</span> record = csv.GetRecord&lt;MyClass&gt;();
<span class="hljs-keyword">var</span> record = csv.GetRecord( <span class="hljs-keyword">typeof</span>( MyClass ) );

<span class="hljs-comment">// Dynamic</span>
<span class="hljs-keyword">var</span> record = csv.GetRecord&lt;<span class="hljs-keyword">dynamic</span>&gt;();

<span class="hljs-comment">// Using anonymous type for the class definition</span>
<span class="hljs-keyword">var</span> anonymousTypeDefinition =
{
    Id = <span class="hljs-keyword">default</span>( <span class="hljs-keyword">int</span> ),
    Name = <span class="hljs-keyword">string</span>.Empty,
    MyClass = <span class="hljs-keyword">new</span> MyClass()
};
<span class="hljs-keyword">var</span> record = csv.GetRecord( anonymousTypeDefinition );</code></pre></div></div><h2 id="getting-fields" class="title is-2"><span>Getting Fields</span></h2><hr/>

<div class="columns"><div class="column"><p>If you need a more granular way of getting records, you are able to get individual fields.</p></div></div><h3 id="indexer" class="title is-3"><span>Indexer</span></h3><div class="columns"><div class="column"><p>You can use an indexer to get by position or name. This will return the field as a <code>string</code>.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-comment">// Don't forget to read the data before getting it.</span>
csv.Read();

<span class="hljs-comment">// By position</span>
<span class="hljs-keyword">var</span> field = csv[<span class="hljs-number">0</span>];

<span class="hljs-comment">// By header name</span>
<span class="hljs-keyword">var</span> field = csv[<span class="hljs-string">"HeaderName"</span>];</code></pre></div></div><h3 id="getfield" class="title is-3"><span>GetField</span></h3><div class="columns"><div class="column"><p>You can get fields converted to a specific type.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-comment">// Don't forget to read the data before getting it.</span>
csv.Read();

<span class="hljs-comment">// Gets field by position returning string</span>
<span class="hljs-keyword">var</span> field = csv.GetField( <span class="hljs-number">0</span> );

<span class="hljs-comment">// Gets field by position returning int</span>
<span class="hljs-keyword">var</span> field = csv.GetField&lt;<span class="hljs-keyword">int</span>&gt;( <span class="hljs-number">0</span> );

<span class="hljs-comment">// Gets field by header name returning bool</span>
<span class="hljs-keyword">var</span> field = csv.GetField&lt;<span class="hljs-keyword">bool</span>&gt;( <span class="hljs-string">"IsTrue"</span> );

<span class="hljs-comment">// Gets field by header name returning object</span>
<span class="hljs-keyword">var</span> field = csv.GetField( <span class="hljs-keyword">typeof</span>( <span class="hljs-keyword">bool</span> ), <span class="hljs-string">"IsTrue"</span> );</code></pre></div></div><h3 id="trygetfield" class="title is-3"><span>TryGetField</span></h3><div class="columns"><div class="column"><p>If there data isn&#39;t consistent and sometimes may not be able to be converted to the correct type, you can use the <code>TryGetField</code> methods.</p></div></div><div class="columns"><div class="column"><pre><code class="box cs"><span class="hljs-comment">// Don't forget to read the data before getting it.</span>
csv.Read();

<span class="hljs-keyword">var</span> success = csv.TryGetField&lt;<span class="hljs-keyword">int</span>&gt;( <span class="hljs-number">0</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">string</span> field );</code></pre></div></div><h2 id="malformed-field-fallback" class="title is-2"><span>Malformed Field Fallback</span></h2><hr/>

<div class="columns"><div class="column"><p>If the field is malformed, meaning it doesn&#39;t follow RFC 4180, some fallback strategies are used so the fields can still be read. In general, this is how a malformed file would behave when opened in Excel.</p></div></div><div class="content"><ol><li>\r or \n is used instead of \r\n<div class="content"><ul><li>Both <code>\r</code> and <code>\n</code> are handled as a line ending, just like <code>\r\n</code>.</li>
</ul></div></li>
<li>No \r\n at the end of the file<div class="content"><ul><li>The last row and field is read as if there was a <code>\r\n</code>.</li>
</ul></div></li>
<li>Escaped field has space before first quote.<div class="content"><ul><li>The field is treated as a non escaped field.</li>
<li><code>, &quot;field&quot;,</code> -&gt; <code>][ &quot;field&quot;][</code></li>
</ul></div></li>
<li>Escaped field has characters after second quote.<div class="content"><ul><li>Characters after second quote aren&#39;t modified.</li>
<li><code>,&quot;field&quot; ,</code> -&gt; <code>][field ][</code></li>
<li><code>,&quot;field&quot; &quot;s,</code> -&gt; <code>][field &quot;s][</code></li>
<li><code>,&quot;field &quot;&quot; s&quot;,</code> -&gt; <code>][field &quot; s&quot;][</code></li>
</ul></div></li>
<li>Escaped field has no ending quote.<div class="content"><ul><li>The field will go to the end of the file.</li>
<li><code>a,b,&quot;c\r\nd,e,f\r\n</code> -&gt; <code>[a][b][c\r\nd,e,f\r\n]</code></li>
</ul></div></li>
</ol></div><h2 id="reading-context" class="title is-2"><span>Reading Context</span></h2><hr/>

<div class="columns"><div class="column"><p>When reading, all the information in the system is held in a context object. If you need to get raw system information for some reason, it&#39;s available here. When an exception is thrown, the context is included so you can inspect the current state of the reader.</p></div></div><h2 id="configuration" class="title is-2"><span>Configuration</span></h2><hr/>

<div class="columns"><div class="column"><p>See <a href="http://joshclose.github.io/CsvHelper/test/CsvHelper/configuration">configuration</a></p></div></div><div class="columns"><div class="column"><p><br/></p></div></div></div></div></div></div><script type="text/javascript">
                window.__routeData = {"path":"/reading","propsMap":{"__local":"1YCS9D"},"initialProps":{"className":"reading","data":"# Reading\r\n\r\nThis library was created to work as easy as possible without any configuration by default. If your class property names match your CSV file header names, it's as simple as this.\r\n\r\n```cs\r\nvar csv = new CsvReader( textReader );\r\nvar records = csv.GetRecords<MyClass>();\r\n```\r\n\r\n## Getting All Records\r\n<hr/>\r\n\r\nThe most common scenario is using one of the `GetRecords` methods.  You can specify the type of object you want returned, and it will return an `IEnumerable` that will `yield` results. This means when iterating the results, only a single record will be in memory at a time, instead of the entire file. Records aren't pulled until you actually start iterating the results.\r\n\r\nIf you want to use an anonymous type as your record, you can get the records by supplying a type definition. You can use `default( type )` for value types, and `new` for reference types.\r\n\r\n### GetRecords\r\n\r\nReturns an `IEnumerable<T>` of records.\r\n\r\n```cs\r\n// By type\r\nvar records = csv.GetRecords<MyClass>();\r\nvar records = csv.GetRecords( typeof( MyClass ) );\r\n\r\n// Dynamic\r\nvar records = csv.GetRecords<dynamic>();\r\n\r\n// Using anonymous type for the class definition\r\nvar anonymousTypeDefinition =\r\n{\r\n\tId = default( int ),\r\n\tName = string.Empty,\r\n\tMyClass = new MyClass()\r\n};\r\nvar records = csv.GetRecords( anonymousTypeDefinition );\r\n```\r\n\r\n### EnumerateRecords\r\n\r\nYou can also enumerate the records while re-using a class instance that you give.\r\nEach enumeration will hydrate the given record, but only the mapped members. If you\r\nsupplied a map and didn't map one of the members, that member will not get hydrated\r\nwith the current row's data. Be careful. Any methods that you call on the projection\r\nthat force the evaluation of the `IEnumerable`, such as `ToList()`, you will get a\r\nlist where all the records are the same instance you provided that is hydrated with\r\nthe last record in the CSV file.\r\n\r\n```cs\r\nvar record = new MyClass();\r\nvar records = csv.EnumerateRecords( record );\r\nforeach( var r in records )\r\n{\r\n\t// r is the same instance as record.\r\n}\r\n```\r\n\r\n## Reading Records\r\n<hr/>\r\n\r\nTo be able to get individual records or even fields, you need to iterate through the records. This is done using the `Read` methods. `Read` will advance the reader to the next record. You must call `Read` before you can get any records or fields. When `GetRecords`, `Read` is automatically called for you.\r\n\r\n### Read\r\n\r\nThis will advance the reader to the next record.\r\n\r\n```cs\r\ncsv.Read();\r\n```\r\n\r\n### ReadAsync\r\n\r\nThis will advance the reader to the next record asynchronously. If the `TextReader` that was supplied is tied to a network or some other slow to read functionality, reading asynchronously is probably a good idea.\r\n\r\n```cs\r\nawait csv.ReadAsync();\r\n```\r\n\r\n### ReadHeader\r\n\r\nThe header in a CSV file is just another record, but it has special meaning. If your file has a header record, you'll need to read the header after the first read. After that you can loop the records and read them. This will allow you to be able to read headers on different rows, or even multiple headers.\r\n\r\n```cs\r\ncsv.Read();\r\ncsv.ReadHeader();\r\nwhile( csv.Read() )\r\n{\r\n\tvar record = csv.GetRecord<MyClass>();\r\n}\r\n```\r\n\r\n## Getting a Single Record\r\n<hr/>\r\n\r\nSometimes there is a reason that you may need to loop the records yourself. You can still easily get a single record, just like with multiple records.\r\n\r\n### GetRecord\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\n// By type\r\nvar record = csv.GetRecord<MyClass>();\r\nvar record = csv.GetRecord( typeof( MyClass ) );\r\n\r\n// Dynamic\r\nvar record = csv.GetRecord<dynamic>();\r\n\r\n// Using anonymous type for the class definition\r\nvar anonymousTypeDefinition =\r\n{\r\n\tId = default( int ),\r\n\tName = string.Empty,\r\n\tMyClass = new MyClass()\r\n};\r\nvar record = csv.GetRecord( anonymousTypeDefinition );\r\n```\r\n\r\n## Getting Fields\r\n<hr/>\r\n\r\nIf you need a more granular way of getting records, you are able to get individual fields.\r\n\r\n### Indexer\r\n\r\nYou can use an indexer to get by position or name. This will return the field as a `string`.\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\n// By position\r\nvar field = csv[0];\r\n\r\n// By header name\r\nvar field = csv[\"HeaderName\"];\r\n```\r\n\r\n### GetField\r\n\r\nYou can get fields converted to a specific type.\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\n// Gets field by position returning string\r\nvar field = csv.GetField( 0 );\r\n\r\n// Gets field by position returning int\r\nvar field = csv.GetField<int>( 0 );\r\n\r\n// Gets field by header name returning bool\r\nvar field = csv.GetField<bool>( \"IsTrue\" );\r\n\r\n// Gets field by header name returning object\r\nvar field = csv.GetField( typeof( bool ), \"IsTrue\" );\r\n```\r\n\r\n### TryGetField\r\n\r\nIf there data isn't consistent and sometimes may not be able to be converted to the correct type, you can use the `TryGetField` methods.\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\nvar success = csv.TryGetField<int>( 0, out string field );\r\n```\r\n\r\n## Malformed Field Fallback\r\n<hr/>\r\n\r\nIf the field is malformed, meaning it doesn't follow RFC 4180, some fallback strategies are used so the fields can still be read. In general, this is how a malformed file would behave when opened in Excel.\r\n\r\n1. \\r or \\n is used instead of \\r\\n\r\n - Both `\\r` and `\\n` are handled as a line ending, just like `\\r\\n`.\r\n1. No \\r\\n at the end of the file\r\n - The last row and field is read as if there was a `\\r\\n`.\r\n1. Escaped field has space before first quote.\r\n - The field is treated as a non escaped field.\r\n - `, \"field\",` -> `][ \"field\"][`\r\n1. Escaped field has characters after second quote.\r\n - Characters after second quote aren't modified.\r\n - `,\"field\" ,` -> `][field ][`\r\n - `,\"field\" \"s,` -> `][field \"s][`\r\n - `,\"field \"\" s\",` -> `][field \" s\"][`\r\n1. Escaped field has no ending quote.\r\n - The field will go to the end of the file.\r\n - `a,b,\"c\\r\\nd,e,f\\r\\n` -> `[a][b][c\\r\\nd,e,f\\r\\n]`\r\n\r\n## Reading Context\r\n<hr/>\r\n\r\nWhen reading, all the information in the system is held in a context object. If you need to get raw system information for some reason, it's available here. When an exception is thrown, the context is included so you can inspect the current state of the reader.\r\n\r\n## Configuration\r\n<hr/>\r\n\r\nSee <a href=\"/CsvHelper/configuration\">configuration</a>\r\n\r\n<br/>\r\n"},"siteData":{}};</script><script defer="" type="text/javascript" src="http://joshclose.github.io/CsvHelper/test/bootstrap.f10da1f5.js"></script><script defer="" type="text/javascript" src="http://joshclose.github.io/CsvHelper/test/templates/src/components/content.96d459ed.js"></script><script defer="" type="text/javascript" src="http://joshclose.github.io/CsvHelper/test/main.df014947.js"></script></body></html>