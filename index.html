<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>CsvHelper</title>
    <meta name="description" content="A .NET library for reading and writing CSV files. Extremely fast, flexible, and easy to use. Supports reading and writing of custom class objects.">

    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="bootstrap/css/bootstrap-responsive.min.css"/>
	<link rel="stylesheet" href="codemirror/codemirror.css"/>
	<link rel="stylesheet" href="css/main.css"/>
</head>
<body data-spy="scroll" data-target="">
<!--[if lt IE 7]><p class=chromeframe>Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</p><![endif]-->

<header>
	<div class="navbar navbar-fixed-top">
		<div class=navbar-inner>
			<div class="container">
				<a href="#" class="home-link pull-left"><img src="images/logo-small.png" width="30" height="30" /></a>
				<ul class="nav">
					<li><a href="#getting-started">Getting Started</a></li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Reading <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#reading">Reading</a></li>
							<li class="divider"></li>
							<li><a href="#reading-reading-all-records">Reading All Records</a></li>
							<li><a href="#reading-reading-records-manually">Reading Records Manually</a></li>
							<li><a href="#reading-reading-individual-fields">Reading Individual Fields</a></li>
							<li><a href="#reading-try-get-field">TryGetField</a></li>
							<li><a href="#reading-parsing">Parsing</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Writing <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#writing">Writing</a></li>
							<li class="divider"></li>
							<li><a href="#writing-writing-all-records">Writing All Records</a></li>
							<li><a href="#writing-writing-records-manually">Writing Records Manually</a></li>
							<li><a href="#writing-writing-individual-fields">Writing Individual Fields</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Mapping <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#mapping">Mapping</a></li>
							<li class="divider"></li>
							<li><a href="#mapping-auto-mapping">Auto Mapping</a></li>
							<li class="dropdown-submenu">
								<a href="#">Fluent Class Mapping</a>
								<ul class="dropdown-menu">
									<li><a href="#mapping-fluent-class-mapping">Fluent Class Mapping</a></li>
									<li><a href="#mapping-reference-map">Reference Map</a></li>
									<li><a href="#mapping-index">Index</a></li>
									<li><a href="#mapping-name">Name</a></li>
									<li><a href="#mapping-name-index">Name Index</a></li>
									<li><a href="#mapping-ignore">Ignore</a></li>
									<li><a href="#mapping-default">Default</a></li>
									<li><a href="#mapping-type-converter">Type Converter</a></li>
									<li><a href="#mapping-type-converter-options">Type Converter Options</a></li>
									<li><a href="#mapping-convert-using">Convert Using</a></li>
								</ul>
							</li>
						</ul>
					</li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Configuration <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#configuration">Configuration</a></li>
							<li class="divider"></li>
							<li><a href="#configuration-allow-comments">Allow Comments</a></li>
							<li><a href="#configuration-auto-map">Auto Map</a></li>
							<li><a href="#configuration-buffer-size">Buffer Size</a></li>
							<li><a href="#configuration-comment">Comment</a></li>
							<li><a href="#configuration-count-bytes">Count Bytes</a></li>
							<li><a href="#configuration-culture-info">Culture Info</a></li>
							<li><a href="#configuration-delimiter">Delimiter</a></li>
							<li><a href="#configuration-detect-column-count-changes">Detect Column Count Changes</a></li>
							<li><a href="#configuration-encoding">Encoding</a></li>
							<li><a href="#configuration-has-header-record">Has Header Record</a></li>
							<li><a href="#configuration-ignore-header-white-space">Ignore Header White Space</a></li>
							<li><a href="#configuration-ignore-private-accessor">Ignore Private Accessor</a></li>
							<li><a href="#configuration-ignore-reading-exceptions">Ignore Reading Exceptions</a></li>
							<li><a href="#configuration-ignore-quotes">Ignore Quotes</a></li>
							<li><a href="#configuration-is-header-case-sensitive">Is Header Case Sensitive</a></li>
							<li><a href="#configuration-maps">Maps</a></li>
							<li><a href="#configuration-property-binding-flags">Property Binding Flags</a></li>
							<li><a href="#configuration-quote">Quote</a></li>
							<li><a href="#configuration-quote-all-fields">Quote All Fields</a></li>
							<li><a href="#configuration-quote-no-fields">Quote No Fields</a></li>
							<li><a href="#configuration-reading-exception-callback">Reading Exception Callback</a></li>
							<li><a href="#configuration-register-class-map">Register Class Map</a></li>
							<li><a href="#configuration-skip-empty-records">Skip Empty Records</a></li>
							<li><a href="#configuration-trim-fields">Trim Fields</a></li>
							<li><a href="#configuration-trim-headers">Trim Headers</a></li>
							<li><a href="#configuration-unregister-class-map">Unregister Class Map</a></li>
							<li><a href="#configuration-will-throw-on-missing-field">Will Throw On Missing Field</a></li>
						</ul>
					</li>
					<li><a href="#type-conversion">Type Conversion</a></li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Misc <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#change-log">Change Log</a></li>
						</ul>
					</li>
				</ul>
			</div>

			<a href="https://github.com/joshclose/csvhelper" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
		</div>
	</div>
</header>

<div class="container">
	<h1>CsvHelper</h1>
	<p>A .NET library for reading and writing CSV files. Extremely fast, flexible and easy to use. Supports reading and writing of custom class objects.</p>

	<h2 id="getting-started">Getting Started</h2>

	<p>
		To install CsvHelper, run the following from the <a href="http://docs.nuget.org/docs/start-here/using-the-package-manager-console" target="_blank">Package Manager Console.</a>
	</p>

	<p><textarea data-code="">Install-Package CsvHelper</textarea></p>

	<!-- Reading -->
	<section>
	<h2 id="reading">Reading</h2>

	<h3 id="reading-reading-all-records">Reading all records</h3>

	<p>Reading is setup to be as simple as possible. If you have a class structure setup that mirrors the CSV file,
	you can read the whole file into an enumerable.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
var records = csv.GetRecords&lt;MyClass&gt;();</textarea></p>

	<p>If you want to customize how the CSV file maps to your custom class objects, you can use <a href="#mapping">mapping</a>.</p>

	<p>The IEnumerable&lt;T&gt; that is returned will yield results. This means that a result isn't returned until you
	actually access it. This is handy because the whole file won't be loaded into memory, and the file will be read as
	you access each row. If you do something like Count() on the IEnumerable&lt;T&gt;, the whole file needs to be read
	and you won't be able to iterate over it again without starting over. If you need to iterate the records more than
	once (like using Count), you can load everything into a list and the work on the data.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
var records = csv.GetRecords&lt;MyClass&gt;().ToList();</textarea></p>

	<h3 id="reading-reading-records-manually">Reading records manually</h3>

	<p>You can loop the rows and read them manually.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
while( csv.Read() )
{
	var record = csv.GetRecord&lt;MyClass&gt;();
}</textarea></p>

	<h3 id="reading-reading-individual-fields">Reading individual fields</h3>

	<p>You can also read each field manually if you like.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
while( csv.Read() )
{
	var intField = csv.GetField&lt;int&gt;( 0 );
	var stringField = csv.GetField&lt;string&gt;( 1 );
	var boolField = csv.GetField&lt;bool&gt;( "HeaderName" );
}</textarea></p>

	<h3 id="reading-try-get-field">TryGetField</h3>

	<p>If you might have inconsistencies with getting fields, you can use TryGetField.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
while( csv.Read() )
{
	int intField;
	if( !csv.TryGetField( 0, out intField ) )
	{
		// Do something when it can't convert.
	}
}</textarea></p>

	<h3 id=reading-parsing>Parsing</h3>

	<p>You can also use the parser directly without using the reader. The parser will give back an array of strings
	for each row that is read, and null when it is finished.</p>

	<p><textarea>
var parser = new CsvParser( textReader );
while( true )
{
	var row = parser.Read();
	if( row == null )
	{
		break;
	}
}
	</textarea></p>

	</section>

	<!-- Writing -->
	<section>
	<h2 id="writing">Writing</h2>

	<h3 id="writing-writing-all-records">Writing all records</h3>

	<p>Writing is setup to be as simple as possible. If you have a class structure setup that mirrors the CSV file,
		you can write the whole file from an enumerable.</p>

	<p><textarea>
var csv = new CsvWriter( textWriter );
csv.WriteRecords( records );</textarea></p>

	<p>If you want to customize how the CSV file maps to your custom class objects, you can use <a href="#mapping">mapping</a>.</p>

	<h3 id="writing-writing-records-manually">Writing records manually</h3>

	<p>You can loop the objects and write them manually.</p>

	<p><textarea>
var csv = new CsvWriter( textWriter );
foreach( var item in list )
{
	csv.WriteRecord( item );
}</textarea></p>

	<h3 id="writing-writing-individual-fields">Writing individual fields</h3>

	<p>You can also write each field manually if you like.</p>

	<p><textarea>
var csv = new CsvWriter( textWriter );
foreach( var item in list )
{
	csv.WriteField( "a" );
	csv.WriteField( 2 );
	csv.WriteField( true );
	csv.NextRecord();
}</textarea></p>

	</section>

	<!-- Mapping -->
	<section>
	<h2 id="mapping">Mapping</h2>

	<h3 id="mapping-auto-mapping">Auto Mapping</h3>

	<p>If you don't supply a mapping file, auto mapping will be used. Auto mapping will map the properties in your class
	in the order they appear in. If the property is a custom class, it recursively maps the properties from that class
	in the order they appear in. If the auto mapper hits a circular reference, it will stop going down that reference
	branch.</p>

	<h3 id="mapping-fluent-class-mapping">Fluent Class Mapping</h3>

	<p>If your CSV file doesn't match up exactly with your custom class, you can use a fluent class map to set options
	for how the class maps to the file. You need to <a href="#configuration-register-class-map">register your class map</a> in
	configuration.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public MyClassMap()
	{
		Map( m => m.Id );
		Map( m = > m.Name );
	}
}</textarea></p>

	<h4 id="mapping-reference-map">Reference Map</h4>

	<p>Reference maps are used to map a property that is a custom class to it's own mapping that maps those properties
	to several CSV columns. You can nest reference maps as many layers deep as you like.</p>

	<p><textarea>
public sealed class PersonMap : CsvClassMap&lt;Person&gt;
{
	public PersonMap()
	{
		Map( m => m.Id );
		Map( m = > m.Name );
		References&lt;AddressMap&gt;( m => m.Address );
	}
}

public sealed class AddressMap : CsvClassMap&lt;Address&gt;
{
	public AddressMap()
	{
		Map( m => m.Street );
		Map( m => m.City );
		Map( m => m.State );
		Map( m => m.Zip );
	}
}</textarea></p>

	<h4 id="mapping-index">Index</h4>

	<p>When mapping by index you specify the index of the CSV column that that you want to use for that property.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public MyClassMap()
	{
		Map( m => m.Id ).Index( 0 );
		Map( m => m.Name ).Index( 1 );
	}
}</textarea></p>

	<h4 id="mapping-name">Name</h4>

	<p>When mapping by name you specify the name of the CSV column that you want to use for that property. For this to
	work, the CSV file must have a header record. The name you specify must match with the name of the header record.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public MyClassMap()
	{
		Map( m => m.Id ).Name( "The Id Column" );
		Map( m => m.Name ).Name( "The Name Column" );
	}
}</textarea></p>

	<h4 id="mapping-name-index">Name Index</h4>

	<p>Sometimes CSV files have multiple columns with the same name. When this happens, you can use NameIndex to
	specify which column name you are referring to. The NameIndex is NOT the column in the CSV file.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public MyClassMap()
	{
		Map( m => m.FirstName ).Name( "Name" ).NameIndex( 0 );
		Map( m => m.LastName ).Name( "Name" ).NameIndex( 1 );
	}
}</textarea></p>

	<h4 id="mapping-ignore">Ignore</h4>

	<p>Currently this is not used. Mapping will only map properties that you specify. In the future there will be an
	option to auto map within a class map, and any mappings explicitly stated will override the auto mapped ones. When
	this happens, ignore will be used to ignore a property that was auto mapped.</p>

	<h4 id="mapping-default">Default</h4>

	<p>Default is used to set a default value you want to use if the field is empty.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void MyClassMap()
	{
		Map( m => m.Id ).Index( 0 ).Default( -1 );
		Map( m => m.Name ).Index( 1 ).Default( "Unknown" );
	}
}</textarea></p>

	<h4 id="mapping-type-converter">Type Converter</h4>

	<p>If the value of the CSV field can't automatically be converted into the type of the property, you can specify
	a custom CsvHelper.TypeConversion.ITypeConverter to be used to convert the value. See
	<a href="#type-conversion">Type Conversion</a> for documentation on how to create a custom type converter.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public MyClassMap()
	{
		Map( m => m.Id ).Index( 0 ).TypeConverter&lt;MyIdConverter&gt;();
	}
}</textarea></p>

	<h4 id="mapping-type-converter-options">Type Converter Options</h4>

	<p>The default built in converters will handle most cases of type conversion, but sometimes there are some small
	changes that you'd like to make, but don't want to create a whole new type converter that just parses an int
	(for example) differently. You can specify some type converter options to handle these cases.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public MyClassMap()
	{
		Map( m => m.Description ).Index( 0 ).TypeConverterOption( CultureInfo.InvariantCulture );
		Map( m => m.TimeStamp ).Index( 1 ).TypeConverterOption( DateTimeStyles.AdjustToUniversal );
		Map( m => m.Cost ).Index( 2 ).TypeConverterOption( NumberStyles.Currency );
		Map( m => m.CurrencyFormat ).Index( 3 ).TypeConverterOption( "C" );
		Map( m => m.BooleanValue ).Index( 4 ).TypeConverterOption( true, "sure" ).TypeConverterOption( false, "nope" );
	}
}</textarea>

	<h4 id="mapping-convert-using">Convert Using</h4>

	<p>When all else fails, you can use ConvertUsing. ConvertUsing allows you to write custom code inline to
	convert the row into a single property value.</p>

	<p><textarea>
public sealed class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public MyClassMap()
	{
		// Constant value.
		Map( m => m.Constant ).ConvertUsing( row => 3 );
		// Aggregate of two rows.
		Map( m => m.Aggregate ).ConvertUsing( row => row.Get&lt;int&gt;( 0 ) + row.Get&lt;int&gt;( 1 ) );
		// Collection with a single value.
		Map( m => m.Names ).ConvertUsing( row => new List&lt;string&gt;{ row.Get&lt;string&gt;( "Name" ) } );
		// Just about anything.
		Map( m => m.Anything ).ConvertUsing( row =>
		{
			// You can do anything you want in a block.
			// Just make sure to return the same type as the property.
		} );
	}
}</textarea>

	</section>

	<!-- Configuration -->
	<section>
	<h2 id="configuration">Configuration</h2>

	<h3 id="configuration-allow-comments">Allow Comments</h3>

	<p>This flag tells the parser whether comments are enabled.</p>

	<p><textarea>
// Default value
csv.Configuration.AllowComments = false;</textarea></p>

	<h3 id="configuration-auto-map">Auto Map</h3>

	<p>This is used to generate a CsvClassMap from a type automatically without a fluent class mapping. This will try
		to map all properties including creating reference maps for properties that aren't native types. If the auto mapper
		detects a circular reference, it will not continue down that path.</p>

	<p><textarea>
var generatedMap = csv.Configuration.AutoMap&lt;MyClass&gt;();</textarea></p>

	<h3 id="configuration-buffer-size">Buffer Size</h3>

	<p>The size of the internal buffer that is used when reader or writing data to and from the TextReader and
		TextWriter. Depending on where your TextReader or TextWriter came from, you may want to make this value larger or
		smaller.</p>

	<p><textarea>
// Default value
csv.Configuration.BufferSize = 2048;</textarea></p>

	<h3 id="configuration-comment">Comment</h3>

	<p>The value used to denote a line that is commented out.</p>

	<p><textarea>
// Default value
csv.Configuration.Comment = '#';</textarea></p>

	<h3 id="configuration-count-bytes">Count Bytes</h3>

	<p>A flag that will tell the parser to keep a count of all the bytes that have been read. You need to set
		Configuration.Encoding to the same encoding of the CSV file for this to work properly. This will also slow down
		parsing of the file.</p>

	<p><textarea>
// Default value
csv.Configuration.CountBytes = false;</textarea></p>

	<h3 id="configuration-culture-info">Culture Info</h3>

	<p>The culture info used to read and write. This can be overridden per property in the mapping configuration.</p>

	<p><textarea>
// Default value
csv.Configuration.CultureInfo = CultureInfo.CurrentCulture;</textarea></p>

	<h3 id="configuration-delimiter">Delimiter</h3>

	<p>The value used to separate the fields in a CSV row.</p>

	<p><textarea>
// Default value
csv.Configuration.Delimiter = ",";</textarea></p>

	<h3 id="configuration-detect-column-count-changes">Detect Column Count Changes</h3>

	<p>This flag will check for changes in the number of column from row to row. If true and a change is detected, a
		CsvBadDataException will be thrown.</p>

	<p><textarea>
// Default value
csv.Configuration.DetectColumnCountChanges = false;</textarea></p>

	<h3 id="configuration-encoding">Encoding</h3>

	<p>The encoding of the CSV file. This is only used when counting bytes. The underlying TextReader and TextWriter
		will have it's own encoding that is used.</p>

	<p><textarea>
// Default value
csv.Configuration.Encoding = Encoding.UTF8;</textarea></p>

	<h3 id="configuration-has-header-record">Has Header Record</h3>

	<p>This flag tells the reader/writer if there is a header row in the CSV file. The must be true
		for mapping properties by name to work (and there must be a header row).</p>

	<p><textarea>
// Default value
csv.Configuration.HasHeaderRecord = true;</textarea></p>

	<h3 id="configuration-ignore-header-white-space">Ignore Header White Space</h3>

	<p>This flag tells the reader to ignore white space in the headers when matching the columns to the properties by
		name.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnoreHeaderWhiteSpace = false;</textarea></p>

	<h3 id="configuration-ignore-private-accessor">Ignore Private Accessor</h3>

	<p>A flag that tells the reader and writer to ignore private accessors when reading and writing. By default you
		can't read from a private getter or write to a private setter. Turn this on will allow that. Properties that can't
		be read from or written to are silently ignored.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnorePrivateAccessor = false;</textarea></p>

	<h3 id="configuration-ignore-reading-exceptions">Ignore Reading Exceptions</h3>

	<p>A flag that tells the reader to swallow any exceptions that occur while reading and to continue on. Exceptions
		that occur in the parser will not be ignored. Parser exceptions mean the file is bad in some way, and the parser
		isn't able to recover.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnoreReadingExceptions = false;</textarea></p>

	<h3 id="configuration-ignore-quotes">Ignore Quotes</h3>

	<p>A flag that tells the parser to ignore quotes as an escape character and treat it like any other character.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnoreQuotes = false;</textarea></p>

	<h3 id="configuration-is-header-case-sensitive">Is Header Case Sensitive</h3>

	<p>This flag sets whether matching CSV header names will be case sensitive.</p>

	<p><textarea>
// Default value
csv.Configuration.IsHeaderCaseSensitive = true;</textarea></p>

	<h3 id="configuration-maps">Maps</h3>

	<p>You are able to access the registered class maps.</p>

	<p><textarea>
var myMap = csv.Configuration.Maps[typeof( MyClass )];</textarea></p>

	<h3 id="configuration-property-binding-flags">Property Binding Flags</h3>

	<p>PropertyBindingFlags are the flags used to find the properties on the custom class.</p>

	<p><textarea>
// Default value
csv.Configuration.PropertyBindingFlags = BindingFlags.Public | BindingFlags.Instance;</textarea></p>

	<h3 id="configuration-quote">Quote</h3>

	<p>The value used to escape fields that contain a delimiter, quote, or line ending.</p>

	<p><textarea>
// Default value
csv.Configuration.Quote = '"';</textarea></p>

	<h3 id="configuration-quote-all-fields">Quote All Fields</h3>

	<p>A flag that tells the writer whether all fields written should have quotes around them; regardless if the field
		contains anything that should be escaped. Both QuoteAllFields and QuoteNotFields cannot be true at the same time.
		Setting one to true will set the other to false.</p>

	<p><textarea>
// Default value
csv.Configuration.QuoteAllFields = false;</textarea></p>

	<h3 id="configuration-quote-no-fields">Quote No Fields</h3>

	<p>A flag that tell the writer whether all fields written should not have quotes around them; regardless if the
		field contains anything that should be escaped. Both QuoteAllFields and QuoteNotFields cannot be true at the same
		time. Setting one to true will set the other to false.</p>

	<p><textarea>
// Default value
csv.Configuration.QuoteAllFields = false;</textarea></p>

	<h3 id="configuration-reading-exception-callback">Reading Exception Callback</h3>

	<p>If you have Configuration.IgnoreReaderExceptions on and you want to know that the exceptions have occurred and
		possibly do something with them, you can use this.</p>

	<p><textarea>
csv.Configuration.ReadingExceptionCallback = ( ex, row ) =>
{
	// Log the exception and current row information.
};</textarea></p>

	<h3 id="configuration-register-class-map">Register Class Map</h3>

	<p>When using fluent class mapping, you need to register class maps for them to be used. You can register multiple
	class maps to be used.</p>

	<p><textarea>
csv.Configuration.RegisterClassMap&lt;MyClassMap&gt;();
csv.Configuration.RegisterClassMap&lt;AnotherClassMap&gt;();</textarea></p>

	<h3 id="configuration-skip-empty-records">Skip Empty Records</h3>

	<p>A flag to let the reader know if a record should be skipped when reading if it's empty. A record is considered
		empty if all fields are empty.</p>

	<p><textarea>
// Default value
csv.Configuration.SkipEmptyRecords = false;</textarea></p>

	<h3 id="configuration-trim-fields">Trim Fields</h3>

	<p>This flag tells the reader to trim whitespace from the beginning and ending of the field value when reading.</p>

	<p><textarea>
// Default value
csv.Configuration.TrimFields = false;</textarea></p>

	<h3 id="configuration-trim-headers">Trim Headers</h3>

	<p>This flag tells the reader to ignore white space from the beginning and ending of the headers when matching the
		columns to the properties by name.</p>

	<p><textarea>
// Default value
csv.Configuration.TrimHeaders = false;</textarea></p>

	<h3 id="configuration-unregister-class-map">Unregister Class Map</h3>

	<p>You can unregister a class map if needed.</p>

	<p><textarea>
// Unregister single map.
csv.Configuration.UnregisterClassMap&lt;MyClassMap&gt;();
// Unregister all class maps.
csv.Configuration.UnregisterClassMap();</textarea></p>

	<h3 id="configuration-will-throw-on-missing-field">Will Throw On Missing Field</h3>

	<p>This flag indicates if an exception should be thrown if reading and an expected field is missing. This is useful
	if you want to know if there is an issue with the CSV file.</p>

	<p><textarea>
// Default value
csv.Configuration.WillThrowOnMissingField = true;</textarea></p>

	</section>

	<!-- Type Conversion -->
	<section>
	<h2 id="type-conversion">Type Conversion</h2>

	<p>Type converters are the way CsvHelper converts strings into .NET types, and .NET types into strings. The CsvHelper
	type converter ecosystem stays close to the .NET</p>
	</section>

	<!-- Miscellaneous -->
	<section>
	<h2>Miscellaneous</h2>

	<h3 id="change-log">Change Log</h3>

	<h4>2.7</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue where using dynamic proxy objects would always automap instead of using a registered class map.</li>
		<li>Fixed issue when trimming fields and the field is null.</li>
		<li>Fixed issue when writing a field and the value is nul.</li>
		<li>Removed deprecated writer methods.</li>
	</ul>

	<h4>2.6.1</h4>

	<h5>Features</h5>

	<ul>
		<li>PCL implementation. .NET 4.0+, Silveright 4.0+, WP7 7.5+, Windows 8</li>
		<li>Excel separator record reading and writing.</li>
		<li>Writer speed enhancements. Thanks to thecontrarycat.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue with mapping order when no index is specified.</li>
	</ul>

	<h4>2.6</h4>

	<h5>Features</h5>

	<ul>
		<li>Added config to prefix headers of reference properties with the parent property name when automapping.</li>
		<li>Ability to ignore blank lines. When this config option is set to false, the parser will return and array of
		nulls. You can differentiate between a row with commas this way. The reader will behave the same way as a blank
		record.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue when writing and a reference map type is a struct.</li>
	</ul>

	<h4>2.5</h4>

	<h5>Features</h5>

	<ul>
		<li>Global type converter options.</li>
		<li>Easier access to property maps to allow for changing maps on the fly.</li>
		<li>Option to ignore references when auto mapping.</li>
		<li>AutoMap functionality is available in class maps.</li>
		<li>Mappings can be specified in the constructor of the mapping class. Overriding CreateMap is now deprecated.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Updated ConvertUsing to not cause the exception "Operation Could Destabilize the Runtime" when property is a
		nullable type and a non-nullable type is returned.</li>
	</ul>

	<h4>2.4.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue where parsing would add delimiter chars to the field when the buffer ran out in the middle of the delimiter.</li>
	</ul>

	<h4>2.4</h4>

	<h5>Features</h5>

	<ul>
		<li>Split writing up into a writer and serializer so the writer can write other things besides CSV files.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue where a NullReferenceException was thrown when using reference maps and a reference was null.</li>
		<li>Fixed issue where TryGetField was throwing MissingFieldException.</li>
		<li>Fixed issue where a commented row on the last line that doesn't have a newline will return the commented row.</li>
		<li>Fixed NuGet package for WP8.</li>
		<li>Added missing WriteHeader methods to ICsvWriter that were a part of CsvWriter.</li>
	</ul>

	<h4>2.3</h4>

	<h5>Features</h5>

	<ul>
		<li>Support for TimeSpan.</li>
		<li>Support for writing records of type dynamic. The dynamic objects do not work with collections, which means ExpandoObject doesn't currently work.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue with extra exception info not being added when the reading exception callback is used.</li>
		<li>Fixed issue where having only reference maps throws exception.</li>
	</ul>

	<h4>2.2.2</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue with parser where a line wouldn't end if the previous char was a \0.</li>
	</ul>

	<h4>2.2.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue with trimming fields not working under one path.</li>
	</ul>

	<h4>2.2.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added Row property to ICsvReader.</li>
		<li>Config option to trim headers and values when reading.</li>
	</ul>

	<h4>2.1.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue when WillThrowOnMissingField is off and exception was still being thrown.</li>
	</ul>

	<h4>2.1.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Made RegisterClassMap overload with CsvClassMap instance public.</li>
	</ul>

	<h4>2.0.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Made a WinRT Any CPU build and removed the arch specific WinRT builds.</li>
	</ul>

	<h4>2.0.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added parser configuration to ignoring quotes and treating them like any other character.</li>
		<li>Added CsvFactory to create ICsvParser, ICsvReader, and ICsvWriter classes. This is useful
		when you need to unit test code that uses CsvHelper since these 3 classes require a TextReader
		or TextWriter to work.</li>
		<li>All assembly versions are strong named but will use a single version of 2.0.0.0. The file
		version and NuGet versions will change with every release.</li>
		<li>Removed class type constraint from reading and writing.</li>
		<li>Added non-generic class mapping overload.</li>
		<li>WriteRecords param changed from IEnumerable&ltobject&gt to non-generic IEnumerable.</li>
		<li>Value types can be read and written instead of just custom classes.</li>
		<li>Indexes are automatically set and incremented when mapping in order of the Map and Reference calls.</li>
		<li>Auto mapping with circular reference detection.</li>
		<li>Config option to ignore spaces in header names.</li>
		<li>Fixed exception handling. Exception are no longer wrapped. Exception.Data["CsvHelper"] contains
		CsvHelper specific exception info.</li>
		<li>Row exception can be skipped during GetRecords.</li>
		<li>Renamed IsStrictMode to WillThrowOnMissingField.</li>
		<li>Window Phone 7 & 8 builds.</li>
		<li>Auto mapping will use defined maps if available.</li>
		<li>Type converter options.</li>
		<li>Added IEnumerable converter that throws an exception so people will know that converting to/from
		and enumerable is not supported instead of getting a cryptic error message.</li>
		<li>Dynamic support for reading and writing.</li>
		<li>Multiple maps can be supplied.</li>
		<li>Renamed InvalidateRecordCache to ClearRecordCache.</li>
		<li>Recursive reference mapping down the whole mapping tree.</li>
		<li>Configuration.CultureInfo was added in place of Configuration.UseInvariantCulture.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Getting the exception helper message failed when writing because no parser is available.</li>
		<li>WriteRecords Dynamic invoke had wrong parameter count.</li>
		<li>GetField( string ) was not returning null if the header is not found.</li>
		<li>CsvBadDataException when there were extra columns in the row.</li>
		<li>Raw record corruption.</li>
	</ul>

	<h4>1.17.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Ignore properties that can't be set in attribute mapping.</li>
		<li>Made TypeConverterFactory thread safe.</li>
		<li>Added remove converter method.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with writer exception in WinRT.</li>
	</ul>

	<h4>1.16.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Change TypeConverterFactory to use a set of cache type converters so global type converters can be used.</li>
		<li>Added GetField&lt;T, TConverter&gt; overloads.</li>
		<li>Changed all Activator.CreateInstance calls to use compiled expression trees to create them instead.</li>
		<li>Changed mapping for ConvertUsing to accept a Func so a block expression can be used.</li>
	</ul>

	<h4>1.15.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Support for Silverlight 4 & 5.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue where writing with Configuration.QuoteAllFields enabled will not quote the quotes inside the field.</li>
		<li>Issue with WinRT not building after pull request merge.</li>
	</ul>

	<h4>1.14.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Parse full line on read. This allows for the parser to retain the whole unchanged raw CSV lin on a read.</li>
		<li>Changed delimiter config from a char to a string.</li>
		<li>Iterating records multiple times will throw a CsvReaderException. This is to help stop confusion when 0 results
		are returned the second iteration.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue where EnumConverter isn't created correctly from the TypeConverterFactory.</li>
		<li>Issue with updating count for all closing quotes.</li>
	</ul>

	<h4>1.13.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Configuration to always not quote all fields.</li>
		<li>WriteHeader method is public.</li>
		<li>Added enum converter.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with boolean converter returning true for "no" value.</li>
		<li>Issue with GetMethod in WinRT.</li>
	</ul>

	<h4>1.12.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Isse where an exception was being thrown when reading all records multiple times.</li>
	</ul>

	<h4>1.12.0</h4>

	<h5>Features</h5>

	<ul>
		<li>WinRT support.</li>
	</ul>

	<h4>1.11.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Better exception information added to CsvBadDataException.</li>
	</ul>

	<h4>1.10.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Mapping property for CreateUsing which allows user to specify how the property gets created.</li>
	</ul>

	<h4>1.9.2</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with skipping empty records.</li>
	</ul>

	<h4>1.9.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with detecting column count changes.</li>
	</ul>

	<h4>1.9.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added properties to CsvReaderException to give more information about the error.</li>
		<li>Ability to skip empty records based on config settings.</li>
		<li>Getting by index that doesn't exist will give a default or CsvMissingFieldException.</li>
		<li>Made column count detection a config setting.</li>
		<li>Map option for constructing the row object.</li>
		<li>Throw exception when inconsistent column lengths are detected.</li>
		<li>String.Format support in CsvWriter.</li>
		<li>Excel compatible parsing.</li>
		<li>Parser can keep track of the byte position using an encoding so a user cna seek to a stream and start
		reading from there.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed bug with column count detection.</li>
		<li>Issue with double counting the closing quote.</li>
		<li>Issue where parsing was incorrect when the last row didn't have a CRLF at the end.</li>
		<li>Issue with error messages.</li>
	</ul>

	<h4>1.8.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Writer overload for shouldQuote when writing a field.</li>
		<li>Ability for using alternative names for headers in the configuration.</li>
		<li>Better error messages.</li>
	</ul>

	<h4>1.7.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Configuration to quote all fields when writing.</li>
		<li>Parser keeps a char count of where it's at.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed subclass issue by having the reader and writer use interfaces instead of concrete classes.</li>
	</ul>

	<h4>1.6.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Custom boolean type converter that can convert from 1 and 0 besides the normal conversion.</li>
		<li>Property map configuration to set a default value.</li>
		<li>CsvWriter no longer flushes to the output stream after every record.</li>
		<li>Non-generic overloads for reading, writing, and attribute mapping.</li>
		<li>Invalidate record cache will clear the properties list.</li>
	</ul>

	<h4>1.5.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Support .NET 2.0 and 3.5 builds.</li>
	</ul>

	<h4>1.4.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Case insensitive header matching.</li>
	</ul>

	<h4>1.3.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Removed CsvHelper class.</li>
		<li>Property reference mapping. One level deep.</li>
	</ul>

	<h4>1.2.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Support for multiple duplicate header names.</li>
	</ul>

	<h4>1.1.2</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue when using a readonly or writeonly stream and disposing causes an exception.</li>
	</ul>

	<h4>1.1.1</h4>

	<h5>Features</h5>

	<ul>
		<li>Updated CsvHelper.cs to allow for readonly and writeonly stream.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed DateTimeConverter issue where a white space string would return a DateTime.MinValue instead of null.</li>
	</ul>

	<h4>1.1.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed .NET 3.5 project to client profile.</li>
		<li>Added getter for the current record in the header.</li>
	</ul>

	<h4>1.0.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed strict mode to default to true.</li>
		<li>Renamed strict mode configuration property.</li>
		<li>Changed reader to not throw an exception when there are duplicate header records unless in strict mode.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed bug where if there is no line ending at the end of the file, the last field would be null instead of
			an empty string.</li>
		<li>Fixed configuration references and constructor signatures.</li>
	</ul>

	<h4>0.16.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added configuration option for using CultureInvariant to read/write.</li>
		<li>Updated the reader/writer to use the config option.</li>
		<li>Both CsvReader and CsvWriter are using Local culture when converting from/to strings.</li>
		<li>CsvClassMap without generic argument.</li>
	</ul>

	<h4>0.15.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed TryGetField&lt;T&gt; to do a low level check instead of jsut wrapping in try/catch blocks.</li>
		<li>Removed non generic TryGetField methods.</li>
		<li>Formatting changes.</li>
		<li>Changed CsvParser to use the Configuration.Comment char instead of #.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed indentation error caused by new constructor in CsvPropertyMap.</li>
	</ul>

	<h4>0.14.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed GetRecords&lt;T&gt; to return IEnumerable&lt;T&gt;.</li>
		<li>Added convenience constructor to CsvPropertyMap.</li>
		<li>Major configuration overhaul.</li>
		<li>Changed end of file check to be more low level.</li>
		<li>Final record is returned if there is a trailing delimiter.</li>
		<li>Added an exception re-throw to parsing that tells the line and character number.</li>
		<li>Added ability to change what the quote char is.</li>
		<li>Added CSV specific exceptions.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fix for issue when CsvHelper uses CurrentCulture instead of InvariantCulture.</li>
	</ul>

	<h4>0.13.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed StreamReader to TextReader to be more generic.</li>
	</ul>

	<h4>0.12.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added option to have a commented out line using '#' as the first character of the line.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue with spaces in non-quoted field.</li>
	</ul>

	</section>
</div>

<script src="js/jquery-1.10.1.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script src="codemirror/codemirror.js"></script>
<script src="codemirror/mode/clike/clike.js"></script>
<script src="js/main.js"></script>

<!--
<script>
    var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
        g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
        s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
-->
</body>
</html>
