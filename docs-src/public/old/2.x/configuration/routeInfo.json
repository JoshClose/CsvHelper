{"path":"configuration","templateID":0,"sharedPropsHashes":{},"localProps":{"className":"configuration","data":"# Configuration\r\n\r\nCsvHelper was created to be fast and simple out of the box. Sometimes the box doesn't fit, and you need to change things. CsvHelper has a lot of configuration options to change the behavior of reading and writing. This will especially help with reading non-[standard](https://tools.ietf.org/html/rfc4180) files.\r\n\r\n## Malicious Injection Protection\r\n<hr/>\r\n\r\nFrom [Comma Separated Vulnerabilities](https://www.contextis.com/blog/comma-separated-vulnerabilities):\r\n\r\n> Many modern web applications and frameworks offer spreadsheet export functionality, allowing users to download data in a .csv or .xls file suitable for handling in spreadsheet applications like Microsoft Excel and OpenOffice Calc.  The resulting spreadsheetâ€™s cells often contain input from untrusted sources such as survey responses, transaction details, and user-supplied addresses. This is inherently risky, because any cells starting with the `=` character will be interpreted by the spreadsheet software as formulae.\r\n\r\nAnother good article: [The Absurdly Underestimated Dangers of CSV Injection](http://georgemauer.net/2017/10/07/csv-injection.html)\r\n\r\n### SanitizeForInjection\r\n\r\nSanitizes fields to prevent malicious injection. When opening a CSV in an external program, a formula in a field could be ran that contains a vulnerability. Due to this issue, if a field starts with characters `=`, `@`, `+`, or `-`, that field will be prepended with a `\\t`. If the field is quoted, the `\\t` will come after the `\"`. Sanitization covers MS Excel, Google Sheets, and Open Office Calc.\r\n\r\n```cs\r\n// Turn off sanitization.\r\ncsv.Configuration.SanitizeForInjection = false;\r\n```\r\n\r\n### InjectionCharacters\r\n\r\nThe list of characters that cause sanitization to occur.\r\n\r\n```cs\r\n// Default.\r\ncsv.Configuration.InjectionCharacters = new [] { '=', '@', '+', '-' };\r\n```\r\n\r\n### InjectionEscapeCharacter\r\n\r\nThe character that is used to escape the injection characters.\r\n\r\n```cs\r\n// Default.\r\ncsv.Configuration.InjectionEscapeCharacter = '\\t';\r\n```\r\n\r\n## Headers\r\n<hr/>\r\n\r\n### HasHeaderRecord\r\n\r\nBy default CsvHelper assumes there is a header record. If your file doesn't have a header record, you can turn this off.\r\n\r\n```cs\r\ncsv.Configuration.HasHeaderRecord = false;\r\n```\r\n\r\n### HeaderValidationCallback\r\n\r\nFunction that is called when a header validation check is ran. The default function will throw a `ValidationException` if there is no header for a given member mapping.\r\n\r\n```cs\r\n// Turn off header validation.\r\ncsv.Configuration.HeaderValidationCallback = null;\r\n\r\n// Log instead of throwing an exception.\r\ncsv.Configuration.HeaderValidationCallback = ( isValid, headerNames, headerNameIndex, context ) =>\r\n{\r\n\tif( !isValid )\r\n\t{\r\n\t\tlogger.WriteLine( $\"Header matching ['{string.Join( \"', '\", headerNames )}'] names at index {headerNameIndex} was not found.\" );\r\n\t}\r\n};\r\n```\r\n\r\n### PrepareHeaderForMatch\r\n\r\nPrepares the header field for matching against a member name. The header field and the member name are both ran through this function. You should do things like trimming, removing whitespace, removing underscores, and making casing changes to ignore case.\r\n\r\n```cs\r\n// Trim\r\ncsv.Configuration.PrepareHeaderForMatch = header => header?.Trim();\r\n\r\n// Remove whitespace\r\ncsv.Configuration.PrepareHeaderForMatch = header => header.Replace( \" \", string.Empty );\r\n\r\n// Remove underscores\r\ncsv.Configuration.PrepareHeaderForMatch = header => header.Replace( \"_\", string.Empty );\r\n\r\n// Ignore case\r\ncsv.Configuration.PrepareHeaderForMatch = header => header.ToLower();\r\n```\r\n\r\n## Mapping\r\n<hr/>\r\n\r\nConfiguration used with class mapping.\r\n\r\n### RegisterClassMap\r\n\r\nAdds a class map. You can register multiple class maps. If you register a map for the same type, the new map will overwrite the old one.\r\n\r\n```cs\r\n// Creates and adds a map for the given  class map type `TMap`.\r\ncsv.Configuration.RegisterClassMap<TMap>();\r\n\r\n// Creates and adds a map for the given class map type\r\ncsv.Configuration.RegisterClassMap( classMapType );\r\n\r\n// Adds the given class map.\r\ncsv.Configuration.RegisterClassMap( classMap );\r\n```\r\n\r\n### UnregisterClassMap\r\n\r\nRemoves a class map.\r\n\r\n```cs\r\n// Removes the class map for the given class map type.\r\ncsv.Configuration.UnregisterClassMap<TMap>();\r\n\r\n// Removes the class map for the given class map type.\r\ncsv.Configuration.UnregisterClassMap( Type classMapType );\r\n\r\n// Removes all class maps.\r\ncsv.Configuration.UnregisterClassMap();\r\n```\r\n\r\n### Maps\r\n\r\nThe configured maps. This is of type `ClassMapCollection` which has some extra methods to help with managing the class maps.\r\n\r\n```cs\r\n// Finds the `ClassMap` for the given record type `TRecord`.\r\nvar map = csv.Maps.Find<TRecord>();\r\n\r\n// Finds the `ClassMap` for the given type.\r\nvar map = csv.Maps[recordType];\r\n```\r\n\r\n### AutoMap\r\n\r\nCreates a `ClassMap` automatically using defaults.\r\n\r\n```cs\r\n// Creates a ClassMap for given record type `TRecord`.\r\nvar map = csv.Configuration.AutoMap<TRecord>();\r\n\r\n// Creates a ClassMap for the given type.\r\nvar map = csv.Configuration.AutoMap( recordType );\r\n```\r\n\r\n### MemberTypes\r\n\r\nSpecifies the type of member mapped when auto mapping.\r\n\r\n```cs\r\n// Default.\r\ncsv.Configuration.MemberTypes = MemberTypes.Properties;\r\n\r\n// Fields.\r\ncsv.Configuration.MemberTypes = MemberTypes.Fields;\r\n\r\n// Both;\r\ncsv.Configuration.MemberTypes = MemberTypes.Properties | MemberTypes.Fields;\r\n```\r\n\r\n### IncludePrivateMembers\r\n\r\nInclude private members when auto mapping. This can only be used for writing. Reading will need to use constructor mapping.\r\n\r\n```cs\r\n// Turn on.\r\ncsv.Configuration.IncludePrivateMembers = true;\r\n```\r\n\r\n### IgnoreReferences\r\n\r\nIgnores reference members when auto mapping. Default is false.\r\n\r\n```cs\r\n// Ignore reference members.\r\ncsv.Configuration.IgnoreReferences = true;\r\n```\r\n\r\n### PrefixReferenceHeaders\r\n\r\nPrefix headers of reference members with the parent member name.\r\n\r\n```cs\r\n// Turn on.\r\ncsv.Configuration.PrefixReferenceHeaders = true;\r\n```\r\n\r\n## Constructor Mapping\r\n<hr/>\r\n\r\nIf you would like your class created using a constructor with csv fields as the parameters, you can use these options.\r\n\r\n### ShouldUseConstructorParameters\r\n\r\nFunction to determine if constructor parameters should be used to create the class instead of the default constructor and member initialization.\r\n\r\n```cs\r\n// Default\r\ncsv.Configuration.ShouldUseConstructorParameters = type =>\r\n\t!type.HasParameterlessConstructor()\r\n\t&& type.HasConstructor()\r\n\t&& !type.IsUserDefinedStruct()\r\n\t&& !type.IsInterface\r\n\t&& Type.GetTypeCode( type ) == TypeCode.Object;\r\n\r\n// Always use constructor parameters.\r\ncsv.Configuration.ShouldUseConstructorParameters = type => true;\r\n\r\n// Never use constructor parameters.\r\ncsv.Configuration.ShouldUseConstructorParameters = type => false;\r\n```\r\n\r\n### GetConstructor\r\n\r\nFunction that chooses the constructor to use for constructor mapping. Default gets the constructor with the most parameters.\r\n\r\n```cs\r\n// Default\r\ncsv.Configuration.GetConstructor = type => type.GetConstructors().OrderByDescending( c => c.GetParameters().Length ).First();\r\n```\r\n\r\n## Error Handling\r\n<hr/>\r\n\r\nWhen some errors occur, you can change the behavior to do something besides throw an exception; such as ignoring the error and logging it.\r\n\r\n### BadDataFound\r\n\r\nFunction that is called when bad field data is found. A field has bad data if it contains a quote and the field is not quoted (escaped). The default function will throw a `BadDataException`.\r\n\r\n```cs\r\n// Ignore bad data.\r\ncsv.Configuration.BadDataFound = null;\r\n\r\n// Log bad data.\r\ncsv.Configuration.BadDataFound = context =>\r\n{\r\n\tlogger.WriteLine( $\"Bad data found on row '{context.RawRow}'\" );\r\n};\r\n```\r\n\r\n### MissingFieldFound\r\n\r\nFunction that is called when a missing field is found. The default function will throw a `MissingFieldException`.\r\n\r\n```cs\r\n// Ignore missing field.\r\ncsv.Configuration.MissingFieldFound = null;\r\n\r\n// Log missing field.\r\ncsv.Configuration.MissingFieldFound = ( headerNames, index, context ) =>\r\n{\r\n\tlogger.WriteLine( $\"Field with names ['{string.Join( \"', '\", headerNames )}'] at index '{index}' was not found.\" );\r\n};\r\n```\r\n\r\n### ReadingExceptionOccurred\r\n\r\nFunction that is called when a reading exception occurs. The default function will re-throw the given exception.\r\n\r\n```cs\r\n// Ignore reading exception.\r\ncsv.Configuration.ReadingExceptionOccurred = null;\r\n\r\n// Log reading exception.\r\ncsv.Configuration.ReadingExceptionOccurred = exception =>\r\n{\r\n\tlogger.WriteLine( $\"Reading exception: {exception.Message}\" );\r\n};\r\n```\r\n\r\n## Type Conversion\r\n<hr/>\r\n\r\n### TypeConverterCache\r\n\r\nManages `TypeConverter`s. You can add, remove, and get type converters for a type.\r\n\r\n```cs\r\n// Add converter for a type.\r\ncsv.Configuration.TypeConverterCache.AddConverter<MyClass>( converter );\r\ncsv.Configuration.TypeConverterCache.AddConverter( typeof( MyClass ), converter );\r\n\r\n// Remove converter.\r\ncsv.Configuration.TypeConverterCache.RemoveConverter<MyClass>();\r\ncsv.Configuration.TypeConverterCache.RemoveConverter( typeof( MyClass ) );\r\n\r\n// Get existing converter.\r\ncsv.Configuration.TypeConverterCache.GetConverter<MyClass>();\r\ncsv.Configuration.TypeConverterCache.GetConverter( typeof( MyClass ) );\r\n```\r\n\r\n### TypeConverterOptionsCache\r\n\r\nManages `TypeConverterOptions`. You can add, remove, and get options for a type.\r\n\r\n```cs\r\n// Add options for a type.\r\ncsv.Configuration.TypeConverterOptionsCache.AddOptions<MyClass>( options );\r\ncsv.Configuration.TypeConverterOptionsCache.AddOptions( typeof( MyClass ), options );\r\n\r\n// Remove options.\r\ncsv.Configuration.TypeConverterOptionsCache.RemoveOptions<MyClass>();\r\ncsv.Configuration.TypeConverterOptionsCache.RemoveOptions( typeof( MyClass ) );\r\n\r\n// Get existing options.\r\ncsv.Configuration.TypeConverterOptionsCache.GetOptions<string>().CultureInfo = CultureInfo.CurrentCulture;\r\ncsv.Configuration.TypeConverterOptionsCache.GetOptions( typeof( string )).CultureInfo = CultureInfo.CurrentCulture;\r\n```\r\n\r\n## Reading\r\n<hr/>\r\n\r\n### DetectColumnCountChanges\r\n\r\nIf a different column count is detected on rows a `BadDataException` is thrown. Default is false.\r\n\r\n```cs\r\n// Turn on.\r\ncsv.Configuration.DetectColumnCountChanges = true;\r\n```\r\n\r\n### ShouldSkipRecord\r\n\r\nFunction that is called when to determine if a record should be skipped. Default returns false.\r\n\r\n```cs\r\n// Skip if all fields are empty.\r\ncsv.Configuration.ShouldSkipRecord = record =>\r\n{\r\n\treturn record.All( string.IsNullOrEmpty );\r\n};\r\n```\r\n\r\n### IgnoreBlankLines\r\n\r\nIgnores blank lines when reading. A blank line is a line with no characters at all. This is on by default.\r\n\r\n```cs\r\n// Turn off.\r\ncsv.Configuration.IgnoreBlankLines = true;\r\n\r\n// A,B,C  // Header.\r\n//        // When on, this row is skipped. When off, it will be just like the next row.\r\n// ,,     // Not ignored. All fields are empty.\r\n```\r\n\r\n## Parsing\r\n<hr/>\r\n\r\n### TrimOptions\r\n\r\nOptions for trimming fields. `TrimOptions.Trim` trims whitespace around a field. `TrimOptions.InsideQuotes` trims the whitespace inside of quotes around a field.\r\n\r\n```cs\r\ncsv.Configuration.TrimOptions = TrimOptions.Trim;\r\n` field ` -> `field`\r\n` \" field \" ` -> `\" field \"`\r\n\r\ncsv.Configuration.TrimOptions = TrimOptions.InsideQuotes;\r\n` field ` -> ` field `\r\n` \" field \" ` -> ` \"field\" `\r\n\r\ncsv.Configuration.TrimOptions = TrimOptions.Trim | TrimOptions.InsideQuotes;\r\n` \" field \" ` -> \"field\"\r\n```\r\n\r\n### AllowComments\r\n\r\nAllows comments when reading. If this is on, a row that starts with the comment character will be considered a commented out row. If this is off, it will be treated as a normal field. Default is off.\r\n\r\n```cs\r\n// Turn on.\r\ncsv.Configuration.AllowComments = true;\r\n```\r\n\r\n### BufferSize\r\n\r\nThe size of the buffer used when reading. Default is 2048;\r\n\r\n```cs\r\n// Double the buffer size.\r\ncsv.Configuration.BufferSize = csv.Configuration.BufferSize * 2;\r\n```\r\n\r\n### CountBytes\r\n\r\nCounts the number of bytes while parsing. Default is false. This will slow down parsing because it needs to get the byte count of every char for the given encoding. Configuration.Encoding needs to be set correctly for this to be accurate.\r\n\r\n```cs\r\n// Turn on.\r\ncsv.Configuration.CountBytes = true;\r\n\r\n// Get count.\r\nvar byteCount = csv.Context.BytePosition;\r\n```\r\n\r\n### Encoding\r\n\r\nThe encoding to use when counting bytes.\r\n\r\n```cs\r\n// Change to whatever the CSV file was encoded in.\r\ncsv.Configuration.Encoding = Encoding.Unicode;\r\n```\r\n\r\n## Writing\r\n<hr/>\r\n\r\n### QuoteAllFields\r\n\r\nQuotes all fields when writing, regardless of other settings. `QuoteAllFields` and `QuoteNoFields` can't both be on at the same time. Turning one on will turn the other off.\r\n\r\n```cs\r\n// Turn on.\r\ncsv.Configuration.QuoteAllFields = true;\r\n```\r\n\r\n### QuoteNoFields\r\n\r\nQuotes no fields when writing, regardless of other settings. `QuoteNoFields` and `QuoteAllFields` can't both be on at the same time. Turning one on will turn the other off.\r\n\r\n```cs\r\n// Turn on.\r\ncsv.Configuration.QuoteNoFields = true;\r\n```\r\n\r\n### UseNewObjectForNullReferenceMembers\r\n\r\nSpecifies if a new object should be created and used when a reference is null. If true, a new object is created and will have default values that are written. If false, all the fields will be empty. Default is true.\r\n\r\n```cs\r\npublic class A\r\n{\r\n\tpublic int AId { get; set;}\r\n\tpublic B B { get; set; }\r\n}\r\n\r\npublic class B\r\n{\r\n\tpublic int BId { get; set; }\r\n}\r\n\r\nvar list = new List<A>\r\n{\r\n\tnew A { AId = 1 }\r\n};\r\n\r\n// Default.\r\ncsv.Configuration.UseNewObjectForNullReferenceMembers = true;\r\ncsv.WriteRecords( list );\r\n\r\n// Output:\r\n// AId,BId\r\n// 1,0\r\n\r\n// Turn off.\r\ncsv.Configuration.UseNewObjectForNullReferenceMembers = false;\r\ncsv.WriteRecords( list );\r\n\r\n// Output:\r\n// AId,BId\r\n// 1,\r\n```\r\n\r\n## Formatting\r\n<hr/>\r\n\r\n### Delimiter\r\n\r\nThe delimiter used to separate fields.\r\n\r\n```cs\r\n// Default.\r\ncsv.Configuration.Delimiter = \",\";\r\n```\r\n\r\n### Quote\r\n\r\nThe quote used to escape fields.\r\n\r\n```cs\r\n// Default.\r\ncsv.Configuration.Quote = '\"';\r\n```\r\n\r\n### Comment\r\n\r\nThe character used to denote a line that is commented out.\r\n\r\n```cs\r\n// Default.\r\ncsv.Configuration.Comment = '#';\r\n```\r\n\r\n### CultureInfo\r\n\r\n### IgnoreQuotes\r\n\r\n<br/>\r\n"}}
