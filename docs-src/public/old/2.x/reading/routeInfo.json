{"path":"reading","templateID":0,"sharedPropsHashes":{},"localProps":{"className":"reading","data":"# Reading\r\n\r\nThis library was created to work as easy as possible without any configuration by default. If your class property names match your CSV file header names, it's as simple as this.\r\n\r\n```cs\r\nvar csv = new CsvReader( textReader );\r\nvar records = csv.GetRecords<MyClass>();\r\n```\r\n\r\n## Getting All Records\r\n<hr/>\r\n\r\nThe most common scenario is using one of the `GetRecords` methods.  You can specify the type of object you want returned, and it will return an `IEnumerable` that will `yield` results. This means when iterating the results, only a single record will be in memory at a time, instead of the entire file. Records aren't pulled until you actually start iterating the results.\r\n\r\nIf you want to use an anonymous type as your record, you can get the records by supplying a type definition. You can use `default( type )` for value types, and `new` for reference types.\r\n\r\n### GetRecords\r\n\r\nReturns an `IEnumerable<T>` of records.\r\n\r\n```cs\r\n// By type\r\nvar records = csv.GetRecords<MyClass>();\r\nvar records = csv.GetRecords( typeof( MyClass ) );\r\n\r\n// Dynamic\r\nvar records = csv.GetRecords<dynamic>();\r\n\r\n// Using anonymous type for the class definition\r\nvar anonymousTypeDefinition = new\r\n{\r\n\tId = default( int ),\r\n\tName = string.Empty,\r\n\tMyClass = new MyClass()\r\n};\r\nvar records = csv.GetRecords( anonymousTypeDefinition );\r\n```\r\n\r\n### EnumerateRecords\r\n\r\nYou can also enumerate the records while re-using a class instance that you give.\r\nEach enumeration will hydrate the given record, but only the mapped members. If you\r\nsupplied a map and didn't map one of the members, that member will not get hydrated\r\nwith the current row's data. Be careful. Any methods that you call on the projection\r\nthat force the evaluation of the `IEnumerable`, such as `ToList()`, you will get a\r\nlist where all the records are the same instance you provided that is hydrated with\r\nthe last record in the CSV file.\r\n\r\n```cs\r\nvar record = new MyClass();\r\nvar records = csv.EnumerateRecords( record );\r\nforeach( var r in records )\r\n{\r\n\t// r is the same instance as record.\r\n}\r\n```\r\n\r\n## Reading Records\r\n<hr/>\r\n\r\nTo be able to get individual records or even fields, you need to iterate through the records. This is done using the `Read` methods. `Read` will advance the reader to the next record. You must call `Read` before you can get any records or fields. When `GetRecords`, `Read` is automatically called for you.\r\n\r\n### Read\r\n\r\nThis will advance the reader to the next record.\r\n\r\n```cs\r\ncsv.Read();\r\n```\r\n\r\n### ReadAsync\r\n\r\nThis will advance the reader to the next record asynchronously. If the `TextReader` that was supplied is tied to a network or some other slow to read functionality, reading asynchronously is probably a good idea.\r\n\r\n```cs\r\nawait csv.ReadAsync();\r\n```\r\n\r\n### ReadHeader\r\n\r\nThe header in a CSV file is just another record, but it has special meaning. If your file has a header record, you'll need to read the header after the first read. After that you can loop the records and read them. This will allow you to be able to read headers on different rows, or even multiple headers.\r\n\r\n```cs\r\ncsv.Read();\r\ncsv.ReadHeader();\r\nwhile( csv.Read() )\r\n{\r\n\tvar record = csv.GetRecord<MyClass>();\r\n}\r\n```\r\n\r\n## Getting a Single Record\r\n<hr/>\r\n\r\nSometimes there is a reason that you may need to loop the records yourself. You can still easily get a single record, just like with multiple records.\r\n\r\n### GetRecord\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\n// By type\r\nvar record = csv.GetRecord<MyClass>();\r\nvar record = csv.GetRecord( typeof( MyClass ) );\r\n\r\n// Dynamic\r\nvar record = csv.GetRecord<dynamic>();\r\n\r\n// Using anonymous type for the class definition\r\nvar anonymousTypeDefinition =\r\n{\r\n\tId = default( int ),\r\n\tName = string.Empty,\r\n\tMyClass = new MyClass()\r\n};\r\nvar record = csv.GetRecord( anonymousTypeDefinition );\r\n```\r\n\r\n## Getting Fields\r\n<hr/>\r\n\r\nIf you need a more granular way of getting records, you are able to get individual fields.\r\n\r\n### Indexer\r\n\r\nYou can use an indexer to get by position or name. This will return the field as a `string`.\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\n// By position\r\nvar field = csv[0];\r\n\r\n// By header name\r\nvar field = csv[\"HeaderName\"];\r\n```\r\n\r\n### GetField\r\n\r\nYou can get fields converted to a specific type.\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\n// Gets field by position returning string\r\nvar field = csv.GetField( 0 );\r\n\r\n// Gets field by position returning int\r\nvar field = csv.GetField<int>( 0 );\r\n\r\n// Gets field by header name returning bool\r\nvar field = csv.GetField<bool>( \"IsTrue\" );\r\n\r\n// Gets field by header name returning object\r\nvar field = csv.GetField( typeof( bool ), \"IsTrue\" );\r\n```\r\n\r\n### TryGetField\r\n\r\nIf there data isn't consistent and sometimes may not be able to be converted to the correct type, you can use the `TryGetField` methods.\r\n\r\n```cs\r\n// Don't forget to read the data before getting it.\r\ncsv.Read();\r\n\r\nvar success = csv.TryGetField<int>( 0, out string field );\r\n```\r\n\r\n## Malformed Field Fallback\r\n<hr/>\r\n\r\nIf the field is malformed, meaning it doesn't follow RFC 4180, some fallback strategies are used so the fields can still be read. In general, this is how a malformed file would behave when opened in Excel.\r\n\r\n1. \\r or \\n is used instead of \\r\\n\r\n - Both `\\r` and `\\n` are handled as a line ending, just like `\\r\\n`.\r\n1. No \\r\\n at the end of the file\r\n - The last row and field is read as if there was a `\\r\\n`.\r\n1. Escaped field has space before first quote.\r\n - The field is treated as a non escaped field.\r\n - `, \"field\",` -> `][ \"field\"][`\r\n1. Escaped field has characters after second quote.\r\n - Characters after second quote aren't modified.\r\n - `,\"field\" ,` -> `][field ][`\r\n - `,\"field\" \"s,` -> `][field \"s][`\r\n - `,\"field \"\" s\",` -> `][field \" s\"][`\r\n1. Escaped field has no ending quote.\r\n - The field will go to the end of the file.\r\n - `a,b,\"c\\r\\nd,e,f\\r\\n` -> `[a][b][c\\r\\nd,e,f\\r\\n]`\r\n\r\n## Reading Context\r\n<hr/>\r\n\r\nWhen reading, all the information in the system is held in a context object. If you need to get raw system information for some reason, it's available here. When an exception is thrown, the context is included so you can inspect the current state of the reader.\r\n\r\n## Configuration\r\n<hr/>\r\n\r\nSee <a href=\"/CsvHelper/configuration\">configuration</a>\r\n\r\n<br/>\r\n"}}
