{"path":"writing","templateID":0,"sharedPropsHashes":{},"localProps":{"className":"writing","data":"# Writing\r\n\r\nThis library was created to work as easy as possible without any configuration by default. If your class property names match your CSV file header names, it's as simple as this.\r\n\r\n```cs\r\nvar records = new List<MyClass> { ... };\r\nvar csv = new CsvWriter( textWriter );\r\ncsv.WriteRecords( records );\r\n```\r\n\r\n<h2 id=\"injection-warning\" class=\"title is-2 has-text-danger\">\r\n\t<span>Injection Warning</span>\r\n</h2>\r\n\r\n<hr/>\r\n\r\nWhen opening a CSV in an external program, a formula in a field could be ran that contains a vulnerability. Read more here: [Comma Separated Vulnerabilities](https://www.contextis.com/blog/comma-separated-vulnerabilities). Due to this issue, if a field starts with characters `=`, `@`, `+`, or `-`, that field will be prepended with a `\\t`. If the field is quoted, the `\\t` will come after the `\"`.\r\n\r\n```\r\n=one   -> \\t=one\r\n\"=one\" -> \"\\t=one\"\r\n```\r\n\r\nYou are able to turn off this functionality in configuration.\r\n\r\n```cs\r\ncsv.Configuration.SanitizeForInjection = false;\r\n```\r\n\r\n## Writing All Records\r\n\r\n<hr/>\r\n\r\nThe most common scenario is using the `WriteRecords` method. You can pass it an `IEnumerable` of records and it will write those objects.\r\n\r\n### WriteRecords\r\n\r\nWrites all records.\r\n\r\n```cs\r\nvar records = new List<MyClass>\r\n{\r\n\tnew MyClass { Id = 1, Name = \"one\" },\r\n\tnew MyClass { Id = 2, Name = \"two\" },\r\n};\r\ncsv.WriteRecords( records );\r\n\r\n// Dynamic\r\nvar records = new List<dynamic>();\r\ndynamic record = new ExpandoObject();\r\nrecord.Id = 1;\r\nrecord.Name = \"one\";\r\nrecords.Add( record );\r\ncsv.WriteRecords( records );\r\n\r\n// Anonymous\r\nvar records = new List<object>\r\n{\r\n\tnew { Id = 1, Name = \"one\" },\r\n\tnew { Id = 2, Name = \"two\" },\r\n};\r\ncsv.WriteRecords( records );\r\n```\r\n\r\n## Writing a Single Record\r\n\r\n<hr/>\r\n\r\nSometimes you want to write individual records by themselves. When you are done writing the row, don't forget to call `NextRecord` to flush the data and write the line ending.\r\n\r\n### WriteHeader\r\n\r\nWrites the header record. You can call this method on any row if you want to write multiple headers.\r\n\r\n```cs\r\ncsv.WriteHeader<MyClass>();\r\ncsv.WriteHeader( Type type );\r\ncsv.NextRecord();\r\n```\r\n\r\n### WriteRecord\r\n\r\nWrites a record.\r\n\r\n```cs\r\nvar record = new MyClass { Id = 1, Name = \"one\" };\r\ncsv.WriteRecord( record );\r\ncsv.NextRecord();\r\n\r\n// Dynamic\r\ndynamic record = new ExpandoObject();\r\nrecord.Id = 1;\r\nrecord.Name = \"one\";\r\ncsv.WriteRecord( record );\r\ncsv.NextRecord();\r\n\r\n// Anonymous\r\nvar record = new { Id = 1, Name = \"one\" };\r\ncsv.WriteRecord( record );\r\ncsv.NextRecord();\r\n```\r\n\r\n## Writing Fields\r\n\r\n<hr/>\r\n\r\nYou can even write a single field.\r\n\r\n### WriteField\r\n\r\nWrite any type of object to a field. You can specify your own `ITypeConverter` to handle converting the type to a string if none of the built in converters work for you.\r\n\r\n```cs\r\n// Write a string\r\ncsv.WriteField( \"field\" );\r\n\r\n// Write a string passing in a value indicating\r\n// if the field should be quoted. This will ignore\r\n// any configuration and only quote based on the\r\n// shouldQuote parameter passed in.\r\ncsv.WriteField( \"field\", true );\r\n\r\n// Write any type\r\ncsv.WriteField( 1 );\r\n\r\n// Write any type and use the given type converter\r\n// to convert the type to a string.\r\ncsv.WriteField( value, myTypeConverter );\r\n\r\n// Write any type and use the given type converter\r\n// to convert the type to a string.\r\ncsv.WriteField<MyTypeConverter>( value );\r\n\r\n// Write a field that has already been converted\r\n// by a type converter. If the field is null, it\r\n// won't get written.\r\ncsv.WriteConvertedField( \"field\" );\r\n\r\n// Don't forget to forget to end the row.\r\ncsv.NextRecord();\r\n```\r\n\r\n### WriteComment\r\n\r\nThis will write text to the field using the comment character supplied in `Configuration.Comment`.\r\n\r\n```cs\r\ncsv.WriteComment( \"This is a comment. \");\r\ncsv.NextRecord();\r\n```\r\n\r\n## Ending the Row\r\n\r\n<hr/>\r\n\r\nWhen you are done writing the row, you need to flush the fields and start a new row. Flushing and starting a new row are separated so that you can flush without creating a new row. Calling `NextRecord` will flush for you.\r\n\r\n### Flush\r\n\r\nSerialize the fields to the `TextReader`.\r\n\r\n```cs\r\ncsv.Flush();\r\n```\r\n\r\n### FlushAsync\r\n\r\nSerialize the fields to the `TextReader` asynchronously. If the `TextReader` supplied is tied to a network or some other slow to write functionality, flushing asynchronously is probably a good idea.\r\n\r\n```cs\r\ncsv.FlushAsync();\r\n```\r\n\r\n### NextRecord\r\n\r\nEnds the current record and starts a new record. This will call `Flush` then write a newline.\r\n\r\n```cs\r\ncsv.NextRecord();\r\n```\r\n\r\n### NextRecordAsync\r\n\r\nEnds the current record and start a new record asynchronously. This will call `FlushAsync` then asynchronously write a newline.\r\n\r\n```cs\r\ncsv.NextRecordAsync();\r\n```\r\n\r\n## Writing Context\r\n\r\n<hr/>\r\n\r\nWhen writing, all the information in the system is held in a context object. If you need to get raw system information for some reason, it's available here. When an exception is throw, the context is included so you can inspect the current state of the writer.\r\n\r\n## Configuration\r\n\r\n<hr/>\r\n\r\nSee <a href=\"/CsvHelper/configuration\">configuration</a>\r\n\r\n<br/>\r\n"}}
